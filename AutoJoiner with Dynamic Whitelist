-- --- Whitelist Configuration (MUST MATCH Server .env/Config) ---
getgenv().key = 'FlameIsSoCool' -- Your Whitelist Key
local rayKey = "4c2e8a1d5f9b6e0c7a3f8b5d2e7c1a9f0e8d" -- Private Key 1 (Secure)
local rayKey2 = "z9x8c7v6b5n4m3l2k1j0h9g8f7d6s5a4q3w2e1r" -- Private Key 2 (Secure)
local SecretNum = "a69g7f3x0j1zs59c8k2y7v4h1l6b0t2" -- Shared Secret Number (Secure)

-- --- Server URLs ---
local SERVER_URI = "https://gptajrailway-production.up.railway.app" 
local API_URL = SERVER_URI .. "/jobids" 
local PLACE_ID = 109983668079237

-- --- Services ---
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")
local GuiService = game:GetService("GuiService")

local player = Players.LocalPlayer
local jobIds = {}

-- --- Base64 Encoder (Needed for Client-Side Comparison) ---
-- This function is used to replicate the server's encoding exactly.
local b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
local function base64enc(data)
   return ((data:gsub('.', function(x)
       local r, b = '', x:byte()
       for i = 8, 1, -1 do
           r = r .. (b % 2 ^ i - b % 2 ^ (i - 1) > 0 and '1' or '0')
       end
       return r;
   end) .. '0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
       if (#x < 6) then
           return ''
       end
       local c = 0
       for i = 1, 6 do
           c = c + (x:sub(i, i) == '1' and 2 ^ (6 - i) or 0)
       end
       return b64chars:sub(c + 1, c + 1)
   end) .. ({'', '==', '='})[#data % 3 + 1])
end

-- --- Dynamic Whitelist Check ---

local key_check_url = SERVER_URI..'?key='..getgenv().key
local URI_Data = nil

-- Attempt to get the dynamic token from the server (blocking call)
local success, result = pcall(function()
    URI_Data = game:HttpGet(key_check_url)
end)

if not success or not URI_Data then
    -- Failed to reach server or unexpected error
    game:GetService('Players').LocalPlayer:Kick('Whitelist Check Failed: Server Unreachable or HTTP Error')
    return
elseif URI_Data == 'Invalid Key' then
    -- Static key check failed
    game:GetService('Players').LocalPlayer:Kick('Invalid Key')
    return
end

-- 1. Extract the encoded payload (middle part of the response)
local parts = string.split(URI_Data, '.')
local received_encoded_payload = parts[2]

-- 2. Calculate the expected payload using the client's current time
-- Get the client's current time (H:M) for stable comparison
local current_time_string = tostring(os.date('%H')..':'..os.date('%M'))

-- Construct the expected inner payload string: Key + PK1 + Time (H:M) + SecretNum + PK2
-- This MUST match the concatenation done on the Node.js server.
local expected_inner_payload = tostring(getgenv().key..rayKey..current_time_string..':'..SecretNum..rayKey2)

-- Encode the expected payload using the client's Base64 encoder
local expected_encoded_payload = base64enc(expected_inner_payload)

-- 3. Final Comparison: Time and Secrets Check
if received_encoded_payload ~= expected_encoded_payload then
   -- Kick if the server's time (in the key) does not match the client's current time.
   game:GetService('Players').LocalPlayer:Kick('Not Whitelisted or Whitelist Error (Time Mismatch)')
   return
end

-- If we reach here, the whitelist check passed successfully.
print('[AutoJoiner Whitelist] Access Granted. Proceeding to load functions.')

-- --- BEGIN AUTOJOINER CORE LOGIC ---

-- Fetch job IDs (unchanged logic)
local function fetchJobIds()
    local success, result = pcall(function()
        if syn and syn.request then
            local response = syn.request({Url = API_URL, Method = "GET"})
            return HttpService:JSONDecode(response.Body)
        elseif request then
            local response = request({Url = API_URL, Method = "GET"})
            return HttpService:JSONDecode(response.Body)
        elseif http_request then
            local response = http_request({Url = API_URL, Method = "GET"})
            return HttpService:JSONDecode(response.Body)
        elseif http and http.request then
            local response = http.request({Url = API_URL, Method = "GET"})
            return HttpService:JSONDecode(response.Body)
        else
            warn("No HTTP function found!")
            return nil
        end
    end)

    if success and result then
        jobIds = result
        print("[AutoJoiner] Fetched " .. #jobIds .. " jobs")
        return true
    else
        warn("[AutoJoiner] Failed to fetch job IDs: " .. tostring(result))
        return false
    end
end

-- Teleport function (unchanged logic)
local function teleportToJob(jobId)
    if not jobId then return end
    if CoreGui:FindFirstChild("RobloxPromptGui") and CoreGui.RobloxPromptGui:FindFirstChild("promptOverlay") then
        CoreGui.RobloxPromptGui.promptOverlay.Visible = false
    end
    pcall(function()
        TeleportService:TeleportToPlaceInstance(PLACE_ID, jobId, player)
    end)
    task.delay(0.5, function()
        if CoreGui:FindFirstChild("RobloxPromptGui") and CoreGui.RobloxPromptGui.promptOverlay:FindFirstChild("ErrorPrompt") then
            if CoreGui.RobloxPromptGui.promptOverlay.ErrorPrompt.MessageArea.ErrorFrame.ButtonArea:FindFirstChild("OkButton") then
                GuiService:SetCore("SendNotification", {Title="AutoJoiner", Text="Error: Invalid Job ID"})
            else
                GuiService:SetCore("SendNotification", {Title="AutoJoiner", Text="Joining server..."})
            end
        end
    end)
end

-- GUI (unchanged logic)
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "AutoJoinerGUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = CoreGui

local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 220, 0, 270)
mainFrame.Position = UDim2.new(0, 20, 0.5, -135)
mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
mainFrame.BorderSizePixel = 0
mainFrame.Parent = screenGui
Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 12)

local titleBar = Instance.new("Frame")
titleBar.Size = UDim2.new(1, 0, 0, 30)
titleBar.BackgroundColor3 = Color3.fromRGB(45, 45, 60)
titleBar.BorderSizePixel = 0
titleBar.Parent = mainFrame
Instance.new("UICorner", titleBar).CornerRadius = UDim.new(0, 12)

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -35, 1, 0)
title.Position = UDim2.new(0, 10, 0, 0)
title.BackgroundTransparency = 1
title.Text = "AutoJoiner 1-5"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.TextSize = 15
title.Font = Enum.Font.GothamBold
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = titleBar

local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, 25, 0, 25)
closeBtn.Position = UDim2.new(1, -30, 0, 2)
closeBtn.BackgroundColor3 = Color3.fromRGB(255, 60, 60)
closeBtn.Text = "X"
closeBtn.TextColor3 = Color3.new(1, 1, 1)
closeBtn.TextSize = 12
closeBtn.Font = Enum.Font.GothamBold
closeBtn.Parent = titleBar
Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0, 6)
closeBtn.MouseButton1Click:Connect(function()
    screenGui:Destroy()
end)

-- Helper to create buttons (unchanged logic)
local function createJoinButton(num, yPos)
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(1, -20, 0, 35)
    btn.Position = UDim2.new(0, 10, 0, yPos)
    btn.BackgroundColor3 = Color3.fromRGB(70, 130, 255)
    btn.Text = "Join Job " .. num
    btn.TextColor3 = Color3.new(1,1,1)
    btn.TextSize = 14
    btn.Font = Enum.Font.GothamBold
    btn.Parent = mainFrame
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 8)

    btn.MouseEnter:Connect(function()
        TweenService:Create(btn, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(100,160,255)}):Play()
    end)
    btn.MouseLeave:Connect(function()
        TweenService:Create(btn, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(70,130,255)}):Play()
    end)

    btn.MouseButton1Click:Connect(function()
        if #jobIds < num then
            GuiService:SetCore("SendNotification", {Title="AutoJoiner", Text="Less than " .. num .. " job IDs available"})
            return
        end
        teleportToJob(jobIds[num])
    end)
end

-- Create buttons for Jobs 1 to 5 (unchanged logic)
for i = 1, 5 do
    createJoinButton(i, 40 + (i-1)*40)
end

-- Initial fetch (runs after successful whitelist)
task.spawn(function()
    task.wait(1)
    fetchJobIds()
end)

print("[AutoJoiner] Loaded! Ready for jobs 1-5.")
